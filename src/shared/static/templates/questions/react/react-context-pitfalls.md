# ⚠️ Подводные камни при частом использовании Context API

---

## 1. Массовые ререндеры потребителей

Любое изменение `value` в `<Context.Provider>` **сразу** вызывает повторный рендер **всех** потребителей, даже если они используют только часть данных.  

```js
<ThemeContext.Provider value={{ theme, toggleTheme }}>
  <Header />       // ререндерится
  <Sidebar />      // ререндерится
  <Content />      // ререндерится
</ThemeContext.Provider>
```

Решение:

* Делите данные на несколько более «атомарных» контекстов ([dev.to][1])
* Меморизируйте объект значения через `useMemo`

---

## 2. Нестабильные ссылки в `value`

При каждом рендере провайдера создаётся новый объект/функция, даже если данные не изменились по смыслу.

```js
// ❌ создаётся новый объект на каждом рендере
<CountContext.Provider value={{ count, increment }}>
  {children}
</CountContext.Provider>
```

Решение:

```js
const contextValue = useMemo(() => ({ count, increment }), [count]);
<CountContext.Provider value={contextValue}>
  {children}
</CountContext.Provider>
```

---

## 3. Сложное дерево провайдеров

«Провайдер-спагетти» затрудняет понимание и сопровождение:

```jsx
<A.Provider>  
  <B.Provider>  
    <C.Provider>  
      <App />  
    </C.Provider>  
  </B.Provider>  
</A.Provider>
```

* Тестировать и рефакторить труднее
* Легко запутаться, какой провайдер где нужен
  Решение: группируйте провайдеры в один компонент‑обёртку или используйте композицию провайдеров

---

## 4. Переиспользуемость и тесная связка

Компоненты, жёстко завязанные на контексте, **теряют переиспользуемость** вне этого контекста.

* Сложнее выносить в отдельные библиотеки
* Труднее мокировать при тестах
  Решение: по возможности **явно** передавайте критичные данные через props, а не через контекст

---

## 5. Ошибки доступа вне провайдера

Потребитель контекста за пределами соответствующего провайдера получает `undefined` или `defaultValue`, что может привести к runtime‑ошибкам.

```js
function Button() {
  const theme = useContext(ThemeContext); // если нет провайдера — theme может быть неверным
}
```

Решение:

* Всегда оборачивайте дерево в `<Context.Provider>`
* При необходимости проверяйте значение на `undefined`

---

## Итог

* Context удобен, но **не универсален** — разумно ограничивайте область применения.
* Избегайте крупных объектных значений и частых обновлений.
* Разбивайте и мемоизируйте контексты, чтобы избежать лишних ререндеров и сохранить производительность.
