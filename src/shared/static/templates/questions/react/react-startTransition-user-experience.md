# ⚡ Как `startTransition` влияет на пользовательский опыт при быстром вводе?

---

## 1. Обработка ввода без `startTransition`

- При вводе текста вы обычно вызываете `setState(value)` прямо в обработчике `onChange`.  
- Все такие обновления считаются **высокоприоритетными**, и React старается сразу перерендерить компонент.  
- Если рендеринг тяжёлый (например, фильтрация большого списка), интерфейс может **«лагать»**: курсор дёргается, ввод становится неотзывчивым.

---

## 2. Маркировка обновлений как transition

- Вызов `startTransition(() => setQuery(value))` говорит React:  
  > «Это не критическое обновление, можно выполнить его чуть позже» :contentReference[oaicite:0]{index=0}  
- React будет обрабатывать вводы в первую очередь, а тяжёлый ререндер откладывать до свободного времени.

---

## 3. Плавность интерфейса

- Поскольку обновления в transition‑режиме имеют **низкий приоритет**, React не блокирует поток событий клавиатуры.  
- Пользователь получает **моментальный** отклик на нажатия клавиш, даже если внутри компонента выполняются дорогостоящие вычисления.

---

## 4. Оптимизация рендеринга

- Transition‑обновления могут быть разделены на несколько фреймов, что смягчает пиковые нагрузки на CPU.  
- React Scheduler разбивает задачу на **единицы работы (units of work)** и проверяет тайм‑дедлайн перед каждым шагом :contentReference[oaicite:1]{index=1}.

---

## 5. Итог

1. Без `startTransition` быстрый ввод + тяжёлый рендер ⇒ лаги и плохой UX.  
2. С `startTransition` ввод обрабатывается мгновенно, а рендеринг выполняется фоново.  
3. Пользователь видит плавный ввод, а интерфейс остаётся отзывчивым, даже когда приложение занято обновлением.  
4. Рекомендуется использовать для поиска, фильтрации, пагинации и любых «дорогих» операций в обработчиках событий.

---
