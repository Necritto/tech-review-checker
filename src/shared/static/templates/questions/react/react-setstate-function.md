# ❓ Зачем в `setState()` (или `useState`) передавать функцию?

---

## Проблема: асинхронность и батчинг

- React может **«паковать»** несколько вызовов `setState` в одно обновление ради производительности.  
- Из‑за этого новое значение `state` может обновляться не сразу: при последовательных вызовах вы **не всегда** получите актуальное предыдущее состояние.

---

## Решение: функциональный (поточный) обновитель

Вместо передачи **прямого значения**:

```js
// ❌ Может привести к некорректному результату
setCount(count + 1);
setCount(count + 1);
```

передаётся **функция**:

```js
// ✅ Всегда надёжно увеличит на 2
setCount((prev) => prev + 1);
setCount((prev) => prev + 1);
```

- React гарантирует, что в `prev` попадает **актуальное** предыдущее состояние, даже при батчинге.

---

## Классические и функциональные компоненты

### В классах

```jsx
this.setState((prevState) => ({
  counter: prevState.counter + 1
}));
```

### В хуках

```jsx
const [count, setCount] = useState(0);

setCount((prev) => prev + 1);
```

---

## Когда использовать

- **Зависимые обновления:** когда новое значение **зависит** от предыдущего (`+1`, `toggle`, `push` в массив).
- **Несколько подряд:** несколько `setState` внутри одного обработчика.
- **Гарантия корректности** при асинхронных колбэках (`setTimeout`, `fetch.then`, `useEffect`).

---

## Итог

- Передача функции в `setState` решает проблему **устаревших** (stale) значений.
- Гарантирует **предсказуемость** при батчинге и асинхронных обновлениях.
- Всегда используйте функциональный обновитель, если новое состояние зависит от предыдущего.
