# ⚠️ Риски и ограничения у автоматического batching в React

---

## 1. Потенциальные stale‑значения

- При объединении нескольких `setState` в один ререндер может возникнуть ситуация, когда **замкнутые** (stale) значения читаются из предыдущего рендера, если вы полагаетесь на не‑функциональный вызов:

    ```jsx
    // ❌ может прочитать одно и то же count в двух вызовах
    setCount(count + 1);
    setCount(count + 1);
    ```

- **Решение**: всегда использовать функциональный обновитель:

  ```jsx
  setCount(c => c + 1);
  setCount(c => c + 1);
  ```

---

## 2. Неинтуитивный порядок обновлений

- Автоматический batching **собирает** все обновления внутри одного события или фрейма, что может смещать ожидания по порядку рендеров и сайд‑эффектов (`useEffect`).
- Сайд‑эффекты могут запускаться позже, чем вы рассчитываете:

  ```jsx
  // effect выполнится один раз после всех обновлений
  setA(a + 1);
  setB(b + 1);
  ```

---

## 3. Ограничения на асинхронные колбэки (React <18)

- В версиях **до React 18** batching работал **только** внутри React‑событий.
- В `setTimeout`, промисах и других асинхронных колбэках обновления выполнялись по отдельности, что могло приводить к лишним рендерам.

---

## 4. Непредсказуемость в сторонних обработчиках

- Если вы вызываете `setState` в колбэках, не управляемых React (например, в `addEventListener` напрямую), batching может **не сработать**:

  ```jsx
  window.addEventListener('click', () => {
    setX(x + 1); // может вызвать отдельный ререндер
    setY(y + 1);
  });
  ```

- **Решение**: использовать `startTransition` или оборачивать в React‑событие.

---

## 5. Принудительный сброс batching

- Частое использование `flushSync` (например, для немедленного обновления) **отключает** batching и может привести к избыточным рендерам и падению производительности.
- Используйте с осторожностью и только при крайней необходимости.

---

## Итог

- **Автоматический batching** значительно оптимизирует рендеры, но добавляет слой абстракции в порядок обновлений.
- Чтобы избежать рисков:

  - Используйте **функциональные обновители** (`setState(prev => …)`).
  - Будьте внимательны к асинхронным колбэкам и сторонним обработчикам.
  - Минимизируйте применение `flushSync` и понимайте его влияние.
  - В React 18 убедитесь, что корни созданы через `createRoot`, чтобы batching работал везде.
